exception NoAnswer

datatype pattern = WildcardP
                 | VariableP of string
                 | UnitP
                 | ConstantP of int
                 | ConstructorP of string * pattern
                 | TupleP of pattern list

datatype valu = Constant of int
              | Unit
              | Constructor of string * valu
              | Tuple of valu list

fun g f1 f2 p =
    let 
        val r = g f1 f2 
    in
        case p of
            WildcardP         => f1 ()
          | VariableP x       => f2 x
          | ConstructorP(_,p) => r p
          | TupleP ps         => List.foldl (fn (p,i) => (r p) + i) 0 ps
          | _                 => 0
    end

(**** for the challenge problem only ****)

datatype typ = AnythingT
             | UnitT
             | IntT
             | TupleT of typ list
             | DatatypeT of string

(**** you can put all your code here ****)

(* Pre : Takes a string list. Assume strings in the list 
         have at least one character.
   Post: Returns a string list with only the strings in the
         given list start with an lowercase letter. *)
				
fun only_lowercase list =
    List.filter(fn x => Char.isLower(String.sub(x, 0))) list

(* Pre : Takes a string list.
   Post: Returns the longest string in the list, if the list is empty
         returns ""; in terms of tie, returns the string closest to the 
         beginning of the list. *)
		 
fun longest_string1 list =
    List.foldl (fn (str, result) => if String.size(str) > String.size(result)
				    then str
				    else result) "" list

(* Pre : Takes a string list.
   Post: Returns the longest string in the list, if the list is empty
	 returns ""; in terms of tie, returns the string closest to the
         end of the list. *)
	      
fun longest_string2 list =
    List.foldl (fn (str, result) => if String.size(str) >= String.size(result)
				    then str
				    else result) "" list

(* Pre : Takes a function and a string list.
   Post: Returns a string from the given list with conditions
         defined by the given function. *)

fun longest_string_helper f list =
    List.foldl (fn (str, result) => if f(String.size(str), String.size(result))
				    then str
				    else result) "" list

(* Post: Has the same behavior of function longest_string1. *)

val longest_string3 = longest_string_helper op>

(* Post: Has the same behavior of function longest_string2. *)
					    
val longest_string4 = longest_string_helper op>=

(* Pre : Takes a string list. Assume all strings have 
         at least 1 character.
   Post: Returns the longest string in the given list start
         with an lowercase letter. If no such string is found,
         returns "". For terms of tie, returns the string closest
         to the beginning of the list. *)
					    
fun longest_lowercase list =
    longest_string_helper op> (only_lowercase list)
	
(* Post: Returns a string that all "x" or "X" in the given 
         string is removed and the rest characters in the string
         is capitalized. *)
			  
val caps_no_X_string =
    String.implode o List.map (fn x => Char.toUpper x) o
    List.filter (fn x => x <> #"x" andalso x <> #"X") o String.explode

														

(* Pre : Takes a function and a list.
   Post: Puts elements from the list in the function
         and get the first SOME v from the function,
         returns the value v. *)

fun first_answer f list =
    case list of
	[] => raise NoAnswer
      | first :: rest => case f first of
			     NONE => first_answer f rest
			   | SOME v => v
					   
(* Pre : Takes a function and a list.
   Post: Returns a list option where the elements in the list
         are answers from passing the given list to the given function, 
         in format of SOME 1st where 1st contains all the answers. 
         Returns NONE if any elements from the list after the function 
         has answer NONE. Order doesn't matter. *)
			     
fun all_answers f list =
    let
	fun helper (list, result) =
	    case list of
		[] => SOME result
	      | first :: rest => case f first of
				       NONE => NONE
				     | SOME v => helper(rest, result @ v)
    in
	helper(list, [])
    end

(* #9: (a) g takes two functions and a pattern.
           g returns the number of different pattern generated by the functions.
           We can change the functions so that g returns the number of specific
           tasks depend on the function and patterns. *)

(* #9 (b):
   Post: Takes a pattern and returns how many Wildcard patterns it contains. *)

val count_wildcards = g (fn _ => 1) (fn _ => 0)

(* #9 (c):
   Post: Takes a pattern and returns how many Wildcard patterns it contains
         plus the sum of the string lengths of all the variable in the 
         variable patterns it contains. *)

val count_wild_and_variable_lengths = g (fn _ => 1) (fn x => String.size x)

(* #9 (d):
   Pre : Takes a string and a pattern as a pair.
   Post: Returns the number of times the string appears as a variable 
         in the pattern. Variable names are considered only, 
         the constructor names are not relevant in this case. *)

fun count_a_var (str, p) =
    g (fn _ => 0) (fn x => if str = x then 1 else 0) p

(*
Write a function check_pat that takes a pattern and returns true if and only if all the variables
appearing in the pattern are distinct from each other (i.e., use different strings). The constructor
names are not relevant. Hints: The sample solution uses two helper functions. The first takes a
pattern and returns a list of all the strings it uses for variables. Using foldl with a function that uses
@ is useful in one case. The second takes a list of strings and decides if it has repeats. List.exists may
be useful. Sample solution is 15 lines. These are hints: We are not requiring foldl and List.exists
here, but they make it easier.
 *)
      
fun check_pat 					


			  



			      
    

	

	       
    
(* 
fun g f1 f2 p =
    let 
        val r = g f1 f2 
    in
        case p of
            WildcardP         => f1 ()
          | VariableP x       => f2 x
          | ConstructorP(_,p) => r p
          | TupleP ps         => List.foldl (fn (p,i) => (r p) + i) 0 ps
          | _                 => 0
    end	      
	 *)			       
				       

	
